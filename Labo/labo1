import numpy as np 
# use las sig matrices de ej:
A = np.array([[1,4,9],[1,2,3],[1,1,1]])
B = [[1,4,9],[1,2,3],[1,1]] 
print(A)
print(B)


# Ejercicio 1 
def esCuadrada(matriz: list[[]]):
    columnas = len(matriz[0])
    for i in range(len(matriz)):
        if len(matriz[i]) != columnas:
            res = False 
        else:
            return len(matriz[i]) == columnas


print(esCuadrada(A.tolist())) # si era array no me dejaba
print(esCuadrada(B))


# Ejercicio 2 : completamente robado del apunte acosta - laplagne

def row_echelon(M): # row_echelon significa matriz escalonada por filas 
 A = M.astype(float) 
 r, c = A.shape
 if r == 0 or c == 0:
  return A # no tiene columnas/filas la devuelvo como esta 

 for i in range(len(A)):
  if A[i,0] != 0:
    break # busco elementos != 0 de la primera columna
  else:
    B = row_echelon(A[:,1:]) # si son todos cero paso a la siguiente colmuna 
    return np.hstack([A[:,:1], B]) 

 if i > 0: 
  ith_row = A[i].copy()
  A[i] = A[0] # intercambia filas 
  A[0] = ith_row

 A[0] = A[0] / A[0,0] 
 A[1:] -= A[0] * A[1:,0:1]
 B = row_echelon(A[1:,1:])
 return np.vstack([A[:1], np.hstack([A[1:,:1], B]) ])


C = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])

print(row_echelon(A))
print(row_echelon(C))

# Ejercicio 3: ?? 

# Ejercicio 4: 
def diagonal(matriz: list[[]]):
    res = [] 
    for i in range(len(matriz)): 
        d = []
        j = 0
        for j in range(len(matriz[i])):
            if j != i:
                d.append(0) 
            else: 
                d.append(matriz[i][j])
        res.append(d)    
    return np.array(res) 
print(diagonal(A.tolist()))

# Ejercicio 5: 
def traza(matriz: list[[]]):
    res = 0
    for i in range(len(matriz)): 
        for j in range(len(matriz[i])):
            if j == i:
                res += matriz[i][j]
    return res 
print(traza(A))
print(traza(B))

# Ejercicio 6:
def traspuesta(matriz: list[[]]):
     a = 0
     res = []    
     for i in range(len(matriz[0])):
         fila = []
         for j in range(len(matriz)): 
              fila.append(matriz[j][i])
         res.append(fila)
     return res # para que tenga la formita de matriz uso: np.array(res) 
print(traspuesta(A1))

# Ejercicio 7:
def esSimetrica(matriz: list[[]]):
    A_traspuesta = traspuesta(matriz)
    res = True 
    for i in range(len(matriz)): 
        for j in range(len(matriz)): 
            if matriz[i][j] != A_traspuesta[i][j]:
                res = False 
    return res       
print(esSimetrica(A1))  

# Ejercicio 8:
def calcularAX(A: list[[]], x: list): 
    b = []
    for i in range(len(A)): 
        suma = 0
        for j in range(len(A[i])):
            suma += (A[i][j]*x[j])
        b.append(suma)
    return b 

# Ejercicio 9: 
def intercambiarFilas(A: list[[]], i: int, j: int):
    new = A[i][:]
    A[i] = A[j][:] 
    A[j] = new 
    return A
print(intercambiarFilas(A.tolist(), 0,1))

# Ejercicio 10: 
def sumar_fila_multiplo(A: list[[]], i: int, j: int, s: int): 
    for a in range(len(A[0])):
        A[i][a] = A[i][a] + A[j][a]*s
    return A
print(sumar_fila_multiplo(A,0,1,3))

# Ejercicio 11 
def valorAbsoluto(num: int):
    if num >= 0:
        return num
    else:
        return num * -1
        
def esDiagonalmenteDominante(A: list[[]]):
    res = True 
    for i in range(len(A)):
        d = 0
        s = 0
        for j in range(len(A[i])):
            if i == j:
                d = valorAbsoluto(A[i][j])
            else:
                s += valorAbsoluto(A[i][j])
        if d < s:
            res = False 
    return res 
print(esDiagonalmenteDominante(A.tolist()))

# obs: podria haber usado abs() en lugar de la funcion de valor absoluto pero no se si se puede ya fue
